package uk.ac.sussex.view {	import uk.ac.sussex.model.valueObjects.Message;	import uk.ac.sussex.view.components.MessageDisplayItem;	import uk.ac.sussex.model.MessageListProxy;	import uk.ac.sussex.model.CallInProgressProxy;	import uk.ac.sussex.model.valueObjects.PlayerChar;	import uk.ac.sussex.model.CallHistoryProxy;	import uk.ac.sussex.model.valueObjects.TalkMessage;	import uk.ac.sussex.model.TalkMessageListProxy;	import uk.ac.sussex.view.components.TextMessageDisplayItem;	import uk.ac.sussex.model.TextMessageListProxy;	import uk.ac.sussex.model.valueObjects.TextMessage;	import org.puremvc.as3.multicore.interfaces.*;	import org.puremvc.as3.multicore.patterns.mediator.Mediator;	import flash.events.Event;	import flash.display.Sprite;	import uk.ac.sussex.view.components.TickerMgr;	import uk.ac.sussex.view.components.DirectoryMgr;	import uk.ac.sussex.view.components.CommsView;	import uk.ac.sussex.general.ApplicationFacade;	import uk.ac.sussex.serverhandlers.CommsHandlers;	import uk.ac.sussex.model.PCListProxy;	import uk.ac.sussex.model.PlayerCharProxy;	import uk.ac.sussex.model.TickerProxy;		/**	 * @author em97	 */	public class CommsViewMediator extends Mediator implements IMediator {				public static const NAME:String = "CommsViewMediator";		public static const ADD_COMMS_COMPONENT:String = "AddCommsComponent";		public static const UPDATE_TALK_DIRECTORY:String = "UpdateTalkDirectory";		public static const SEND_TEXTMESSAGE:String = "SendTextMessage";		public static const INITIATE_CALL:String = "InitiateCall";				private var directoryMgr:DirectoryMgr;		private var tickerMgr:TickerMgr;				private var textMessageProxy:TextMessageListProxy;		private var callHistoryProxy:CallHistoryProxy;		private var callInProgressProxy:CallInProgressProxy;		private var messageProxy:MessageListProxy;				public function CommsViewMediator( viewComponent : Object = null) {			super(NAME, viewComponent);		}				override public function listNotificationInterests():Array {			return [CommsViewMediator.ADD_COMMS_COMPONENT, 					TalkMessageListProxy.MESSAGE_ADDED, 					PCListProxy.PLAYER_LIST_UPDATED, 					TickerProxy.TICKER_UPDATED, 					TextMessageListProxy.TEXT_MESSAGE_LIST_UPDATED, 					TextMessageListProxy.TEXT_MESSAGE_UPDATED, 					CallHistoryProxy.RECEIVED_INCOMING,					CallHistoryProxy.RECEIVED_OUTGOING, 					CallInProgressProxy.CALL_BEGUN, 					CallInProgressProxy.CALL_ENDED,					CallInProgressProxy.CALL_ANSWERED, 					CallInProgressProxy.CALL_CONTENT_ADDED, 					MessageListProxy.MESSAGE_LIST_UPDATED,					MessageListProxy.MESSAGE_UPDATED					];		}				override public function handleNotification (note:INotification):void {			var selectedFunction:String = commsView.getSelectedFunction();			switch(note.getName()){				case CommsViewMediator.ADD_COMMS_COMPONENT:					var newChild:Sprite = note.getBody() as Sprite;					commsView.addChild(newChild);					break;				case TalkMessageListProxy.MESSAGE_ADDED:					if(selectedFunction==CommsView.TALK){						var newMessage:TalkMessage = note.getBody() as TalkMessage;						this.displayNewTalkMessage(newMessage);					}					break;				case PCListProxy.PLAYER_LIST_UPDATED:					var listName:String = note.getBody() as String;					trace("CommsViewMediator sez: Player list " + listName + " got updated");										var listProxy:PCListProxy = facade.retrieveProxy(listName) as PCListProxy;					if(listName == CommsHandlers.DIR_TALK_LIST){						directoryMgr.updateTalkDirectory(listProxy.getPCList());						if( selectedFunction == CommsView.TALK){							directoryMgr.updateDirectory(DirectoryMgr.DIR_TALK);						}					} else if (listName == CommsHandlers.DIR_ALL_PCS) {						directoryMgr.updatePhoneDirectory(listProxy.getPCList());					}					break;				case TickerProxy.TICKER_UPDATED:					var tickerMessage:String = note.getBody() as String;					this.updateTicker(tickerMessage);					break;				case TextMessageListProxy.TEXT_MESSAGE_LIST_UPDATED:				case TextMessageListProxy.TEXT_MESSAGE_UPDATED:					if(textMessageProxy == null){						textMessageProxy = facade.retrieveProxy(TextMessageListProxy.NAME) as TextMessageListProxy;					}					//Update the unread count.					updateTextMessageCount();					//This depends on whether we are currently displaying the text messages or not. 					if(commsView.getSelectedFunction() == CommsView.SMS){						updateTextMessages();					}					break;				case MessageListProxy.MESSAGE_LIST_UPDATED:				case MessageListProxy.MESSAGE_UPDATED: 					if(messageProxy == null){						messageProxy = facade.retrieveProxy(MessageListProxy.NAME) as MessageListProxy;					}					updateMessageCount();					if(commsView.getSelectedFunction() == CommsView.MAIL){						updateMessages();					}				case CallHistoryProxy.RECEIVED_INCOMING:				case CallHistoryProxy.RECEIVED_OUTGOING:					trace("CommsViewMediator sez: We have call history to display.");					if(selectedFunction==CommsView.PHONE){						this.displayCallHistory();					}					break;				case CallInProgressProxy.CALL_BEGUN:					trace("CommsViewMediator sez: We have a call on our hands.");					callBegun();					break;				case CallInProgressProxy.CALL_ANSWERED:					trace("CommsViewMediator sez: My call is answered");					callAnswered();					break;				case CallInProgressProxy.CALL_ENDED:					trace("CommsViewMediator sez: My call got ended");					callEnded();					break;				case CallInProgressProxy.CALL_CONTENT_ADDED:					trace("CommsViewMediatory sez: Some call content got added");					var callMessage:TalkMessage = note.getBody() as TalkMessage;					this.displayNewTalkMessage(callMessage);					break;			}		}		private function updateTicker(tickerMessage:String):void {			if(tickerMessage==null || tickerMessage == ""){				tickerMgr.clearTicker();			} else {				tickerMgr.setTickerTxt(tickerMessage);			}		}		private function talkSelected(e:Event):void{			displayAllTalkMessages();			directoryMgr.removeEventListener(DirectoryMgr.PLAYER_SELECTED, initiatePhoneCall);			directoryMgr.updateDirectory(DirectoryMgr.DIR_TALK);		}		private function phoneSelected(e:Event):void {			this.selectPhoneFunctionality();			directoryMgr.updateDirectory(DirectoryMgr.DIR_PHONE);		}		private function smsSelected(e:Event):void {			updateTextMessages();			directoryMgr.removeEventListener(DirectoryMgr.PLAYER_SELECTED, initiatePhoneCall);			directoryMgr.updateDirectory(DirectoryMgr.DIR_PHONE);			}		private function mailSelected(e:Event):void {			updateMessages();			directoryMgr.removeEventListener(DirectoryMgr.PLAYER_SELECTED, initiatePhoneCall);			directoryMgr.updateDirectory(DirectoryMgr.DIR_PHONE);		}		private function sendMessage(e:Event):void {			var selectedFunction:String = commsView.getSelectedFunction();			var message:String = commsView.getPlayerInput();			switch(selectedFunction){				case CommsView.TALK:					if(message.length > 0){						sendNotification(CommsHandlers.SEND_TALK_MESSAGE, message);					}					commsView.clearPlayerInput();					break;				case CommsView.PHONE:					if(message.length > 0){						sendNotification(CommsHandlers.SEND_PHONE_MESSAGE, message);					}					commsView.clearPlayerInput();					break;				case CommsView.SMS:					var recipient:int = directoryMgr.getSelectedPlayerId();					if(recipient==-1){						sendNotification(ApplicationFacade.DISPLAY_MESSAGE, "You need to select a player from the directory to send this message to.");					} else {						if(message.length > 0){ 	// Should we actually let them send blank messages?							var tm:TextMessage = new TextMessage();							tm.setTextMessage(message);							tm.setReceiver(recipient);							sendNotification(SEND_TEXTMESSAGE, tm);						}						commsView.clearPlayerInput();						directoryMgr.clearSelectedPlayer();					}					break;				case CommsView.MAIL:					trace("CommsViewMediator sez: Sending someone a letter?");					break;			}		}		private function displayNewTalkMessage(newMessage:TalkMessage):void {			var myPCProxy:PlayerCharProxy = facade.retrieveProxy(ApplicationFacade.MY_CHAR) as PlayerCharProxy;			if(myPCProxy.getPlayerId() != newMessage.getAuthorId()){				commsView.updateMessageText(newMessage.getMessage(), newMessage.getAuthorName());			} else {				commsView.updateMessageText(newMessage.getMessage(), "You");			}		}		private function displayAllTalkMessages():void {			var talkMessageProxy:TalkMessageListProxy = facade.retrieveProxy(TalkMessageListProxy.NAME) as TalkMessageListProxy;			if(talkMessageProxy!= null){				var talkMessages:Array = talkMessageProxy.getMessages();				if(talkMessages!=null){					for each (var talkMessage:TalkMessage in talkMessages){						displayNewTalkMessage(talkMessage);					}				}			}		}		private function updateTextMessages():void {			commsView.displayTextMessages(textMessageProxy.getTextMessages());		}		private function updateMessages():void {			commsView.displayMessages(messageProxy.getMessages());		}		private function updateTextMessageCount():void {			var unreadCount:uint = textMessageProxy.getUnreadCount();			commsView.displayUnreadSMSCount(unreadCount);		}		private function updateMessageCount():void {			var unreadCount:uint = messageProxy.getUnreadCount();			commsView.displayUnreadMessageCount(unreadCount);		}		private function displaySMSMessage(e:Event):void {			var textMessageId:int = int(commsView.getSelectedMessage());			var textMessage:TextMessage = textMessageProxy.getTextFromId(textMessageId);			var tmDisplay:TextMessageDisplayItem = new TextMessageDisplayItem(textMessage);			tmDisplay.addEventListener(TextMessageDisplayItem.DELETE_CLICKED, deleteSMSMessage);			sendNotification(ApplicationFacade.DISPLAY_OVERLAY_FORM, tmDisplay);			textMessage.setUnread(false);		}		private function deleteSMSMessage(e:Event):void {			trace("CommsViewMediator sez: Delete button was clicked on the overlay.");			//Hm. How to get at that textmessage?			var tmDisplay:TextMessageDisplayItem = e.currentTarget as TextMessageDisplayItem;			tmDisplay.removeEventListener(TextMessageDisplayItem.DELETE_CLICKED, deleteSMSMessage);			sendNotification(ApplicationFacade.CLEAR_OVERLAY);			var tm:TextMessage = tmDisplay.getTextMessage();			tm.setDeleted(true);		}		private function displayMessage(e:Event):void {			trace("CommsViewMediator sez: We'll be displaying a message then.");			var messageId:int = int(commsView.getSelectedMessage());			var message:Message = messageProxy.getMessageById(messageId);			var messageDisplay:MessageDisplayItem = new MessageDisplayItem(message);			messageDisplay.addEventListener(MessageDisplayItem.DELETE_CLICKED, deleteMessage);			sendNotification(ApplicationFacade.DISPLAY_OVERLAY_FORM, messageDisplay);			message.setUnread(false);		}		private function deleteMessage(e:Event):void {			trace("CommsViewMediator sez: We should delete this message now. ");			var messageDisplay:MessageDisplayItem = e.currentTarget as MessageDisplayItem;			messageDisplay.removeEventListener(MessageDisplayItem.DELETE_CLICKED, deleteMessage);			sendNotification(ApplicationFacade.CLEAR_OVERLAY);			var message:Message = messageDisplay.getMessage();			message.setDeleted(true);		}		private function selectPhoneFunctionality():void {			//Try fetching it again. Just in case. 			callInProgressProxy = facade.retrieveProxy(CallInProgressProxy.NAME) as CallInProgressProxy; 			if(callInProgressProxy==null){				//We really aren't in a call. 				this.displayCallHistory();				directoryMgr.addEventListener(DirectoryMgr.PLAYER_SELECTED, initiatePhoneCall);			} else {				//We are in a call.				if(callInProgressProxy.callNeedsAnswering()){					//We should answer the call by clicking this button. 					sendNotification(CommsHandlers.ANSWER_CALL);				} else {					//We should end the call. 					sendNotification(CommsHandlers.END_CALL);				}			}		}		private function displayCallHistory():void {			if(callHistoryProxy==null){				callHistoryProxy = facade.retrieveProxy(CallHistoryProxy.NAME) as CallHistoryProxy;			}			var callHistory:Array = callHistoryProxy.getCallHistoryList();			commsView.displayCallHistory(callHistory);		}		private function initiatePhoneCall(e:Event):void {			directoryMgr.removeEventListener(DirectoryMgr.PLAYER_SELECTED, initiatePhoneCall);						var recipient:PlayerChar = directoryMgr.getSelectedPlayer();			sendNotification(CommsHandlers.INITIATE_CALL, recipient);		}		private function callBegun():void {			callInProgressProxy = facade.retrieveProxy(CallInProgressProxy.NAME) as CallInProgressProxy;			commsView.flashPhoneIcon();			if(commsView.getSelectedFunction()==CommsView.PHONE){				commsView.beginPhoneCall();				var callItems:Array = callInProgressProxy.getCallContent();				for each (var callItem:TalkMessage in callItems){					displayNewTalkMessage(callItem);				}			}		}		private function callAnswered():void {			commsView.stopFlashingPhoneIcon();			commsView.beginPhoneCall();			var callItems:Array = callInProgressProxy.getCallContent();			for each (var callItem:TalkMessage in callItems){				displayNewTalkMessage(callItem);			}		}		private function callEnded():void {			commsView.endPhoneCall();		}				//Cast the viewComponent to the correct type.		protected function get commsView():CommsView {			return viewComponent as CommsView;		}		override public function onRegister():void		{			viewComponent = new CommsView();			//Add the directory manager			directoryMgr = new DirectoryMgr();			directoryMgr.x = 700;			commsView.addChild(directoryMgr);			//Try to get the people lists.			var allPCs:PCListProxy = facade.retrieveProxy(CommsHandlers.DIR_ALL_PCS) as PCListProxy;			if(allPCs!= null){				directoryMgr.updatePhoneDirectory(allPCs.getPCList());			}			var talkPCs:PCListProxy = facade.retrieveProxy(CommsHandlers.DIR_TALK_LIST) as PCListProxy;			if(talkPCs!=null){				directoryMgr.updateTalkDirectory(talkPCs.getPCList());			}			directoryMgr.updateDirectory(DirectoryMgr.DIR_TALK);			this.tickerMgr = new TickerMgr();			var tickerMgrY:Number = commsView.height - tickerMgr.height;			tickerMgr.y = tickerMgrY;						var tp:TickerProxy = facade.retrieveProxy(TickerProxy.NAME) as TickerProxy;			if(tp != null){				this.updateTicker(tp.getTickerMessage());			}			textMessageProxy = facade.retrieveProxy(TextMessageListProxy.NAME) as TextMessageListProxy;			if(textMessageProxy != null){				this.updateTextMessageCount();			}			messageProxy = facade.retrieveProxy(MessageListProxy.NAME) as MessageListProxy;			if(messageProxy != null){				this.updateMessageCount();			}						commsView.addChild(tickerMgr);						var appMediator:ApplicationMediator = facade.retrieveMediator(ApplicationMediator.NAME) as ApplicationMediator;			commsView.y = appMediator.getTopHeight() + appMediator.getCentreHeight();						commsView.addEventListener(CommsView.TALK_SELECTED, talkSelected);			commsView.addEventListener(CommsView.PHONE_SELECTED, phoneSelected);			commsView.addEventListener(CommsView.SMS_SELECTED, smsSelected);			commsView.addEventListener(CommsView.MAIL_SELECTED, mailSelected);			commsView.addEventListener(CommsView.SEND_MESSAGE, sendMessage);			commsView.addEventListener(CommsView.SMS_MESSAGE_SELECTED, displaySMSMessage);			commsView.addEventListener(CommsView.MAIL_MESSAGE_SELECTED, displayMessage);						//Need to check whether they are on a call or not. 			callInProgressProxy = facade.retrieveProxy(CallInProgressProxy.NAME) as CallInProgressProxy;			if(callInProgressProxy!=null && !callInProgressProxy.callNeedsAnswering()){				//This means that you should be in the phone functionality.				commsView.beginPhoneCall();				var callItems:Array = callInProgressProxy.getCallContent();				for each (var callItem:TalkMessage in callItems){					displayNewTalkMessage(callItem);				}				if(callInProgressProxy.getCallAnswered()==0){					commsView.flashPhoneIcon();				}				directoryMgr.updateDirectory(DirectoryMgr.DIR_PHONE);			}						sendNotification(ApplicationFacade.ADD_TO_CONTROLS, commsView);		}		override public function onRemove():void		{			sendNotification(ApplicationFacade.REMOVE_FROM_SCREEN, commsView);		}	}}