/**This file is part of the African Farmer Game - Multiplayer version.African Farmer Game - Multiplayer version is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.African Farmer Game - Multiplayer version is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.You should have received a copy of the GNU General Public License along with African Farmer Game - Multiplayer version.  If not, see <http://www.gnu.org/licenses/>.	**/package uk.ac.sussex.view.components {	import uk.ac.sussex.model.valueObjects.Task;	import uk.ac.sussex.model.valueObjects.AnyChar;	import uk.ac.sussex.model.valueObjects.GameAsset;	import uk.ac.sussex.general.ApplicationFacade;	import uk.ac.sussex.model.valueObjects.TaskLocation;		import flash.events.MouseEvent;		public class TaskListItem extends ListItem {		private var task:Task;		private var number:GameTextField;		private var taskDescription:IconTextBox;		private var taskLocation:IconTextBox;		private var taskAsset:IconTextBox;		private var taskActor:IconTextBox;		private var taskStatus:GameTextField;		private var mouseOver:MouseoverTextField;		private static const GAP_SIZE:Number = 2;		private static const ITEM_Y_POS:uint = 0;		private static const ITEM_HEIGHT:uint = 25;		private static const NOT_REQUIRED:String = "N\A";		private static const NUMBER_WIDTH:uint = 30;		private static const TASK_WIDTH:uint = 150;		private static const LOCATION_WIDTH:uint = 100;		private static const RESOURCES_WIDTH:uint = 110;		private static const LABOUR_WIDTH:uint = 120; 		private static const STATUS_WIDTH:uint = 74; 				public function TaskListItem() {			super();			setup();			this.mouseChildren = false;		}		public function setTask(newTask:Task):void {			this.task = newTask;			number.text = task.getTaskNumber().toString();			this.setItemID(task.getId().toString());			setDescription(task.getTypeDisplay(), task.getLocation().getType());			setLocation(task.getLocation());						var asset:GameAsset = task.getAsset();			var assetIcon:AssetIcon = new AssetIcon();			if(asset!= null){				taskAsset.setText(asset.getName());				assetIcon.setType(asset.getType(), asset.getSubtype());			} else {				taskAsset.setText(NOT_REQUIRED);				assetIcon.setType(AssetIcon.NONE);			}			taskAsset.setBoxIcon(assetIcon);						setActor(task.getActor());			setStatus(task.getStatus());			this.enabled = !task.getReadonly();			if(task.getReadonly()){			  this.alpha = 0.5;			}						this.setNotes(task.getNotes());		}		public function getTask():Task {			return this.task;		}		override public function destroy():void {			if(mouseOver!=null){				mouseOver.removeFromScreen();			}		}		private function setDescription(description:String, locType:String):void {			taskDescription.setText(description);			var taskIcon:PersonIconBorder = new PersonIconBorder();			switch(locType){				case TaskLocation.TYPE_FIELD:					taskIcon.gotoAndStop("GREEN_TRACTOR");					break;				case TaskLocation.TYPE_HEARTH:					taskIcon.gotoAndStop("GREEN_HOUSE");					break;			}			taskDescription.setBoxIcon(taskIcon);		}		private function setLocation(newLocation:TaskLocation):void {			taskLocation.setText(newLocation.getName());			var locIcon:PersonIconBorder = new PersonIconBorder();			switch(newLocation.getType()){				case TaskLocation.TYPE_FIELD:					locIcon.gotoAndStop("WHITE_TRACTOR");					break;				case TaskLocation.TYPE_HEARTH:						locIcon.gotoAndStop("WHITE_HOUSE");					break;			}			taskLocation.setBoxIcon(locIcon);		}		private function setStatus(newTaskStatus:int):void {			switch (newTaskStatus){				case Task.PENDING:					taskStatus.text = "Pending";					break;				case Task.ERROR:					taskStatus.text = "Error";					break;				case Task.COMPLETED:					taskStatus.text = "Completed";					break;			}		}		private function setActor(actor:AnyChar):void {			var actorIcon:PersonIconBorder = new PersonIconBorder();							if(actor!=null){				switch(actor.getRole()){					case ApplicationFacade.MAN:						if(actor.getRelationship()==AnyChar.IMMEDIATE_FAMILY){							actorIcon.gotoAndStop("BLUE_MAN");						} else {							actorIcon.gotoAndStop("WHITE_MAN");						}						break;					case ApplicationFacade.WOMAN:						if(actor.getRelationship()==AnyChar.IMMEDIATE_FAMILY){							actorIcon.gotoAndStop("BLUE_WOMAN");						} else {							actorIcon.gotoAndStop("WHITE_WOMAN");						}						break;				}				taskActor.setBoxIcon(actorIcon);				taskActor.setText(actor.getFirstName() + " " + actor.getFamilyName());			} else {				actorIcon.gotoAndStop("RED_MAN");				taskActor.setBoxIcon(actorIcon);				taskActor.setText("N/A");			}		}		private function setNotes(notes:String):void{		  if(notes!=null){		    this.mouseOver = new MouseoverTextField();		    this.mouseOver.text = notes;		    addEventListeners();		  } else {		    removeEventListeners();		    this.mouseOver = null;		  }		}		private function addEventListeners():void{			this.addEventListener(MouseEvent.MOUSE_OVER, itemMouseOver);			this.addEventListener(MouseEvent.MOUSE_OUT, itemMouseOut);		}		private function removeEventListeners():void {		  this.removeEventListener(MouseEvent.MOUSE_OVER, itemMouseOver);		  this.removeEventListener(MouseEvent.MOUSE_OUT, itemMouseOut);		}		private function setup():void{			number = new GameTextField();			number.readonly = true;			number.width = NUMBER_WIDTH;			number.height = ITEM_HEIGHT;			number.x = 0;			number.y = ITEM_Y_POS;			this.addChild(number);						taskDescription = new IconTextBox();			taskDescription.setBoxIcon(new AssetIcon());			taskDescription.height = ITEM_HEIGHT;			taskDescription.x = number.x + number.width + GAP_SIZE;			taskDescription.y = ITEM_Y_POS;			taskDescription.width = TASK_WIDTH;			this.addChild(taskDescription);						taskLocation = new IconTextBox();			taskLocation.setBoxIcon(new AssetIcon());			taskLocation.height = ITEM_HEIGHT;			taskLocation.width = LOCATION_WIDTH;			taskLocation.y = ITEM_Y_POS;			taskLocation.x = taskDescription.x + taskDescription.width + GAP_SIZE;			this.addChild(taskLocation);						taskAsset = new IconTextBox();			taskAsset.setBoxIcon(new AssetIcon());			taskAsset.height = ITEM_HEIGHT;			taskAsset.width = RESOURCES_WIDTH;			taskAsset.x = taskLocation.x + taskLocation.width + GAP_SIZE;			taskAsset.y = ITEM_Y_POS;			this.addChild(taskAsset);						taskActor = new IconTextBox();			taskActor.setBoxIcon(new AssetIcon());			taskActor.height = ITEM_HEIGHT;			taskActor.width = LABOUR_WIDTH;			taskActor.x = taskAsset.x + taskAsset.width + GAP_SIZE;			taskActor.y = ITEM_Y_POS;			this.addChild(taskActor);						taskStatus = new GameTextField();			taskStatus.readonly = true;			taskStatus.height = ITEM_HEIGHT;			taskStatus.width = STATUS_WIDTH;			taskStatus.x = taskActor.x + taskActor.width + GAP_SIZE;			taskStatus.y = ITEM_Y_POS;			this.addChild(taskStatus);		}		private function itemMouseOver(e:MouseEvent):void {			mouseOver.addToScreen(this, mouseX + 5, mouseY - mouseOver.height);		}		private function itemMouseOut(e:MouseEvent):void {			if(mouseOver!=null){				mouseOver.removeFromScreen();			}			}		public static function getColumnHeaders():Array {			var headers:Array = new Array();						headers.push(new Array("No", NUMBER_WIDTH, 0));			headers.push(new Array("Task", TASK_WIDTH, NUMBER_WIDTH + GAP_SIZE));			headers.push(new Array("Location", LOCATION_WIDTH, NUMBER_WIDTH + 2*GAP_SIZE + TASK_WIDTH));			headers.push(new Array("Resources", RESOURCES_WIDTH, NUMBER_WIDTH + TASK_WIDTH + LOCATION_WIDTH + 3*GAP_SIZE));			headers.push(new Array("Labour", LABOUR_WIDTH, NUMBER_WIDTH + TASK_WIDTH + LOCATION_WIDTH + RESOURCES_WIDTH + 4*GAP_SIZE));			headers.push(new Array("Status", STATUS_WIDTH, NUMBER_WIDTH + TASK_WIDTH + LOCATION_WIDTH + RESOURCES_WIDTH + LABOUR_WIDTH + 5*GAP_SIZE));						return headers;		}	}	}