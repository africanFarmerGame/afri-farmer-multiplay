package uk.ac.sussex.view {	import uk.ac.sussex.serverhandlers.FarmHandlers;	import flash.events.Event;	import uk.ac.sussex.view.components.ScrollingList;	import org.puremvc.as3.multicore.interfaces.INotification;	import uk.ac.sussex.general.ApplicationFacade;	import uk.ac.sussex.model.TaskListProxy;	import uk.ac.sussex.view.components.TaskListDisplay;	import org.puremvc.as3.multicore.patterns.mediator.Mediator;	import org.puremvc.as3.multicore.interfaces.IMediator;	/**	 * @author em97	 */	public class TaskListMediator extends Mediator implements IMediator {		private var taskListProxy:TaskListProxy;		public static const NAME:String = "TaskListMediator";				public function TaskListMediator() {			super(NAME, null);		}		override public function listNotificationInterests():Array {			return [TaskListProxy.HOUSEHOLD_TASKS_ADDED];		}		override public function handleNotification (note:INotification):void {			switch (note.getName()){				case TaskListProxy.HOUSEHOLD_TASKS_ADDED:					var taskLists:Array = taskListProxy.getHouseholdTasks();					taskListDisplay.clearTasks();					taskListDisplay.displayTasks(taskLists);					break;			}		}		public function showList(showList:Boolean):void{			taskListDisplay.clearSelection();			if(showList){				sendNotification(ViewAreaMediator.ADD_VIEW_COMPONENT, taskListDisplay);			} else {				sendNotification(ApplicationFacade.REMOVE_FROM_SCREEN, taskListDisplay);			}		}		public function getSelectedTaskId():String{			return taskListDisplay.getSelectedTaskId();		}		public function listenForSelection(listen:Boolean):void{			if(listen){				taskListDisplay.addEventListener(ScrollingList.ITEM_SELECTED, itemSelected);			} else {				taskListDisplay.removeEventListener(ScrollingList.ITEM_SELECTED, itemSelected);			}		}		public function setDeleting(deleting:Boolean):void {			taskListDisplay.setDeleting(deleting);			if(deleting){				taskListDisplay.addEventListener(TaskListDisplay.CONFIRM_TASK_SELECTION, confirmDeletion);				taskListDisplay.addEventListener(TaskListDisplay.CANCEL_TASK_SELECTION, cancelDeletion);			} else {				taskListDisplay.removeEventListener(TaskListDisplay.CONFIRM_TASK_SELECTION, confirmDeletion);				taskListDisplay.removeEventListener(TaskListDisplay.CANCEL_TASK_SELECTION, cancelDeletion);				}		}		private function itemSelected(e:Event):void {			trace("TaskListMediator sez: I heard a task item has been selected. ");			sendNotification(ApplicationFacade.SWITCH_SUBMENU_ITEM, FarmHandlers.TASK_SUB_MENU_EDIT);			listenForSelection(false);		}		private function confirmDeletion(e:Event):void {			var selectedId:String = taskListDisplay.getSelectedTaskId();			if(selectedId!=null){				sendNotification(FarmHandlers.DELETE_HOUSEHOLD_TASK, selectedId);			}		}		private function cancelDeletion(e:Event):void {			sendNotification(ApplicationFacade.SWITCH_SUBMENU_ITEM, FarmHandlers.TASK_SUB_MENU_LIST);		}		protected function get taskListDisplay():TaskListDisplay {			return viewComponent as TaskListDisplay;		}		override public function onRegister():void {			viewComponent = new TaskListDisplay();			var submenu:SubMenuMediator = facade.retrieveMediator(SubMenuMediator.NAME) as SubMenuMediator;						taskListDisplay.x = submenu.getSubmenuWidth();			taskListDisplay.y = 10;			taskListProxy = facade.retrieveProxy(TaskListProxy.NAME) as TaskListProxy;			sendNotification(ViewAreaMediator.ADD_VIEW_COMPONENT, taskListDisplay);		}		override public function onRemove():void {			sendNotification(ApplicationFacade.REMOVE_FROM_SCREEN, taskListDisplay);			taskListDisplay.destroy();		}	}}