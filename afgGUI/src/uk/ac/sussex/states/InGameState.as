/**This file is part of the African Farmer Game - Multiplayer version.African Farmer Game - Multiplayer version is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.African Farmer Game - Multiplayer version is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.You should have received a copy of the GNU General Public License along with African Farmer Game - Multiplayer version.  If not, see <http://www.gnu.org/licenses/>.	**/package uk.ac.sussex.states {	import uk.ac.sussex.general.ApplicationFacade;	import flash.display.Sprite;	import org.puremvc.as3.multicore.interfaces.IFacade;		import uk.ac.sussex.view.*;	import uk.ac.sussex.model.*;	import uk.ac.sussex.model.valueObjects.requestParams.*;	import uk.ac.sussex.controller.*;	import uk.ac.sussex.serverhandlers.*;		/**	 * @author em97	 */	public class InGameState extends NavFreeGameState implements IGameState  {				public function InGameState(facade:IFacade, name:String, roomDisplayTitle:String = null){			trace("InGameState sez: roomDisplayTitle is " + roomDisplayTitle);			super(facade, name, roomDisplayTitle);		}		override public function displayState() : void {			trace("InGameState sez: at display time roomDisplayTitle is " + roomDisplayTitle);						//Need to get the room display name. 			if(this.roomDisplayTitle == null){				var roomProxy:ServerRoomProxy = facade.retrieveProxy(ServerRoomProxy.NAME) as ServerRoomProxy;				var roomDisplayTitle:String = roomProxy.getRoomDisplayTitle();				this.setDisplayTitle(roomDisplayTitle);			}						super.displayState();			//Register proxies			this.registerProxies();			//Register mediators			this.registerMediators();			//Register commands			this.registerCommands();		}		override public function cleanUpState() : void {			SeasonsHandlers.removeComponents(facade);			CommsHandlers.removeComponents(facade);			//Remove proxies			this.facade.removeProxy(RoomHandlers.MOVE_ROOM + RequestProxy.NAME);			this.facade.removeProxy(RoomHandlers.MOVE_ROOM_ERROR + IncomingDataProxy.NAME);			this.facade.removeProxy(RoomHandlers.ROOM_ERROR + IncomingDataProxy.NAME);			this.facade.removeProxy(RoomHandlers.GET_ROOM_STATUS + RequestProxy.NAME);			this.facade.removeProxy(RoomHandlers.GET_ROOM_STATUS_ERROR + IncomingDataProxy.NAME);			this.facade.removeProxy(RoomHandlers.ROOM_STATUS_DETAIL + IncomingDataProxy.NAME);			//Remove mediators			this.facade.removeMediator(NavMenuMediator.NAME);			//Remove commands			this.facade.removeCommand(GameHandlers.REQUEST_LOCATION_MOVE);			super.cleanUpState();		}		override public function refresh():void {		}		private function registerCommands():void {			this.facade.registerCommand(GameHandlers.REQUEST_LOCATION_MOVE, RequestLocationMoveCommand);			this.facade.registerCommand(RoomHandlers.ROOM_STATUS_DETAIL, NavMenuStatusReceivedCommand);		}		private function registerMediators():void {			var navMenuMediator:NavMenuMediator = new NavMenuMediator(new Sprite()); 			this.facade.registerMediator(navMenuMediator);			var srp:ServerRoomProxy = facade.retrieveProxy(ServerRoomProxy.NAME) as ServerRoomProxy;			var roomType:String = srp.getRoomType(); //If I don't set the banker flag, it should return the right thing.			navMenuMediator.switchButtonHighlight(roomType);			var myChar:PlayerCharProxy = facade.retrieveProxy(ApplicationFacade.MY_CHAR) as PlayerCharProxy;			//If the character is not a banker, and has no hearth id, don't allow them to click on the home button.			if(!myChar.isBanker()){				navMenuMediator.disableButton(HomeGameState.LOCATION_NAME, myChar.getPCHearthId()==0);			}		}		private function registerProxies():void {			var roomErrorProxy:IncomingDataErrorProxy = new IncomingDataErrorProxy(RoomHandlers.ROOM_ERROR);			facade.registerProxy(roomErrorProxy);						var navDetailRequest:RequestProxy = new RequestProxy(RoomHandlers.GET_ROOM_STATUS);			facade.registerProxy(navDetailRequest);			var navDetailIncoming:IncomingDataProxy = new IncomingDataProxy(RoomHandlers.ROOM_STATUS_DETAIL, RoomHandlers.ROOM_STATUS_DETAIL);			navDetailIncoming.addDataParam(new DataParamArrayViewStatus(RoomHandlers.VIEW_DETAILS));			facade.registerProxy(navDetailIncoming);						var navDetailError:IncomingDataErrorProxy = new IncomingDataErrorProxy(RoomHandlers.GET_ROOM_STATUS_ERROR);			facade.registerProxy(navDetailError);			navDetailRequest.sendRequest();						var moveLocationRequest:RequestProxy = new RequestProxy(RoomHandlers.MOVE_ROOM);			moveLocationRequest.addRequestParam(new DataParamString("location"));			moveLocationRequest.addRequestParam(new DataParamString("locId"));			this.facade.registerProxy(moveLocationRequest);			var moveLocationError:IncomingDataProxy = new IncomingDataProxy(RoomHandlers.MOVE_ROOM_ERROR, ApplicationFacade.INCOMING_ERROR_MESSAGE);			moveLocationError.addDataParam(new DataParamString("message"));			facade.registerProxy(moveLocationError);					}	}}