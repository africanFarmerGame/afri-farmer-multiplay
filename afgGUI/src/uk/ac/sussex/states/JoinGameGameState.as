package uk.ac.sussex.states {	import uk.ac.sussex.model.IncomingDataErrorProxy;	import uk.ac.sussex.controller.DisplayServerErrorMessageCommand;	import uk.ac.sussex.controller.DisplayServerMessageCommand;	import uk.ac.sussex.general.ApplicationFacade;	import uk.ac.sussex.model.valueObjects.requestParams.DataParamArrayGame;	import uk.ac.sussex.model.valueObjects.requestParams.DataParamInt;	import org.puremvc.as3.multicore.interfaces.IFacade;	import uk.ac.sussex.view.LogoutButtonMediator;	import flash.display.Sprite;	import uk.ac.sussex.view.CreateNewGameButtonMediator;	import uk.ac.sussex.controller.GameSettingsStatePrepCommand;	import uk.ac.sussex.controller.JoinSelectedGameCommand;	import uk.ac.sussex.controller.SuccessfulCreateGameCommand;	import uk.ac.sussex.model.RequestProxy;	import uk.ac.sussex.model.IncomingDataProxy;	import uk.ac.sussex.view.JoinExistingGameMediator;	import uk.ac.sussex.model.valueObjects.requestParams.DataParamString;		public class JoinGameGameState implements IGameState {		public static const NAME:String = "JoinGameGameState";		public static const CREATE_NEW_GAME:String = "CreateNewGame";		public static const RECEIVED_GAME_LIST:String = "ReceivedGameLists";		public static const GAME_LIST:String = "gameslist";		public static const GAME_SELECTED:String = "gameselected";		public static const GAME_JOIN_SUCCESS:String = "joinGame_success";				private var facade:IFacade;		private static const FETCH_ACTIVE_GAMES:String = "game.fetchActiveGames";		private static const FETCH_ACTIVE_GAMES_ERROR:String = "fetchActiveGames_error";				public function JoinGameGameState(facade:IFacade) {			// constructor code			this.facade = facade;		}		public function displayState():void{			//register proxies			var requestGames:RequestProxy = new RequestProxy(FETCH_ACTIVE_GAMES);			this.facade.registerProxy(requestGames);			requestGames.sendRequest();			var incomingGames:IncomingDataProxy = new IncomingDataProxy(RECEIVED_GAME_LIST, RECEIVED_GAME_LIST);			incomingGames.addDataParam(new DataParamArrayGame(GAME_LIST));			this.facade.registerProxy(incomingGames);			var joinSuccess:IncomingDataProxy = new IncomingDataProxy(GAME_JOIN_SUCCESS, GAME_JOIN_SUCCESS);			joinSuccess.addDataParam(new DataParamString('message'));			this.facade.registerProxy(joinSuccess);			var joinGame:RequestProxy = new RequestProxy("game.joinGame");			joinGame.addRequestParam(new DataParamInt("gameId"));			this.facade.registerProxy(joinGame);			facade.registerProxy(new IncomingDataErrorProxy(FETCH_ACTIVE_GAMES_ERROR));						//register mediators			this.facade.registerMediator(new LogoutButtonMediator());						this.facade.registerMediator(new CreateNewGameButtonMediator(new Sprite()));			this.facade.registerMediator(new JoinExistingGameMediator(new Sprite()));			//register commands			this.facade.registerCommand(CREATE_NEW_GAME, GameSettingsStatePrepCommand);			this.facade.registerCommand(GAME_SELECTED, JoinSelectedGameCommand);			//This is a stopgap, because at the moment it does the same thing regardless.			this.facade.registerCommand(GAME_JOIN_SUCCESS, SuccessfulCreateGameCommand);			facade.registerCommand(ApplicationFacade.INCOMING_MESSAGE, DisplayServerMessageCommand);			facade.registerCommand(ApplicationFacade.INCOMING_ERROR_MESSAGE, DisplayServerErrorMessageCommand);					}		public function cleanUpState():void{			//remove proxies			this.facade.removeProxy("game.fetchActiveGames" + RequestProxy.NAME);			this.facade.removeProxy(GAME_JOIN_SUCCESS + IncomingDataProxy.NAME);			this.facade.removeProxy("game.joinGame" + RequestProxy.NAME);			this.facade.removeProxy(RECEIVED_GAME_LIST + IncomingDataProxy.NAME);			facade.removeProxy(FETCH_ACTIVE_GAMES_ERROR + IncomingDataProxy.NAME);						//remove mediators			this.facade.removeMediator(LogoutButtonMediator.NAME);			this.facade.removeMediator(CreateNewGameButtonMediator.NAME);			this.facade.removeMediator(JoinExistingGameMediator.NAME);						//remove commands			this.facade.removeCommand(CREATE_NEW_GAME);			this.facade.removeCommand(GAME_SELECTED);			facade.removeCommand(ApplicationFacade.INCOMING_MESSAGE);			facade.removeCommand(ApplicationFacade.INCOMING_ERROR_MESSAGE);		}		public function getName():String{			return NAME;		}		public function refresh():void {			var requestGames:RequestProxy = facade.retrieveProxy(FETCH_ACTIVE_GAMES + RequestProxy.NAME) as RequestProxy;			requestGames.sendRequest();					}	}	}